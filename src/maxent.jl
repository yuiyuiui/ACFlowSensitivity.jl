function solve(GFV::Vector{Complex{T}}, ctx::CtxData{T}, alg::MaxEntChi2kink) where {T<:Real}
    L = alg.L
    Œ±‚ÇÅ = T(alg.Œ±‚ÇÅ)
    œÉ = T(alg.œÉ)
    M = length(ctx.mesh)
    maxiter = alg.maxent_iter

    # singular space method
    kernel = Matrix{Complex{T}}(undef, length(GFV), length(ctx.mesh))
    for i ‚àà 1:length(GFV)
        for j ‚àà 1:length(ctx.mesh)
            kernel[i, j] = 1 / (ctx.iwn[i] - ctx.mesh[j])
        end
    end
    G = vcat(real(GFV), imag(GFV))
    K = [real(kernel); imag(kernel)]
    U, S, V = svd(K)
    n = count(x -> (x >= strict_tol(T))/10, S)
    V = V[:, 1:n]
    U = U[:, 1:n]
    S = S[1:n]
    
    model = make_model(alg.model_type, ctx)
    reA = copy(model)
    for i ‚àà 1:maxiter
        model = reA
        reA = chi2kink(G,K,n,U,S,V,model,ctx.mesh_weights,L,Œ±‚ÇÅ,œÉ)
    end
end



function chi2kink(G::Vector{T},K::Matrix{T},n::Int,U::Matrix{T},S::Vector{T},V::Matrix{T},model::Vector{T},w::Vector{T},L::Int,Œ±‚ÇÅ::T,œÉ::T) where {T<:Real}

    Œ±_vec = Vector{T}(undef, L)
    Œ±_vec[1] = Œ±‚ÇÅ
    for i ‚àà 2:L
        Œ±_vec[i] = Œ±_vec[i-1] / 10
    end
    œá¬≤_vec = Vector{T}(undef, L)

    # ÂêéÈù¢log10(Œ±)Âíålog10(œá¬≤)Ë¶ÅÊãüÂêàÁöÑÊõ≤Á∫ø
    function fitfun(x, p)
        return @. p[1] + p[2] / (1 + exp(-p[4] * (x - p[3])))
    end

    # ÊãüÂêàÊõ≤Á∫øÊó∂ÂÄô‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàËÆæÁΩÆÁöÑÂèÇÊï∞
    #adjust = T(2.5)

    # function Q
    A_vec(u::Vector{T}) = model .* exp.(V * u)
    œá¬≤(u::Vector{T}) = (G - K * A_vec(u))' * (G - K * A_vec(u)) / (œÉ^2)
    Q(u::Vector{T}, Œ±::T) = Œ± * (A_vec(u) - model - A_vec(u) .* log.(A_vec(u) ./ model))' * w - 0.5 * œá¬≤(u)

    # -ùûâQ/‚àÇA
    J(u::Vector{Float64}, Œ±::Float64) =
        Œ± * u + 1 / (œÉ^2) * (-diagm(S) * U' * G + d * diagm(S)^2 * V' * A_vec(u))

    # -‚àÇ¬≤Q/‚àÇA‚àÇu
    H(u::Vector{Float64}, Œ±::Float64) =
        Œ± * Matrix(I(n)) + d / (œÉ^2) * diagm(S)^2 * V' * diagm(A_vec(u)) * V



    # Êé•‰∏ãÊù•Áî®Newton methodÊ±ÇÊúÄÂÄºÁÇπ
    u_guess = zeros(n)
    u_opt_vec = Vector{Vector{Float64}}(undef, L)
    for i = 1:L
        # @show i
        Œ± = Œ±_vec[i]
        u_opt, call, _ = my_newton(u -> J(u, Œ±), u -> H(u, Œ±), u_guess)
        u_guess = copy(u_opt)
        u_opt_vec[i] = copy(u_opt)
        œá¬≤_vec[i] = œá¬≤(u_opt)
        # @show log10(Œ±), log10(œá¬≤_vec[i]), norm(J(u_opt, Œ±)), call
    end
    idx = findall(isfinite, œá¬≤_vec)
    Œ±_vec = Œ±_vec[idx]
    œá¬≤_vec = œá¬≤_vec[idx]
    u_opt_vec = u_opt_vec[idx]

    # Áé∞Âú®ËøõË°åÊõ≤Á∫øÊãüÂêà
    guess_fit = [0.0, 5.0, 2.0, 0.0]
    _, _, c, dd = my_curve_fit(log10.(Œ±_vec), log10.(œá¬≤_vec), guess_fit, Newton())[1]


    # ÈÄâÂèñÊãêÁÇπÔºåÂπ∂‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàÊàñËÄÖÊ¨†ÊãüÂêàÂÅö‰∏ÄÂÆöÂ§ÑÁêÜÔºåÂÜçËÆ°ÁÆóÂØπÂ∫îÁöÑu
    Œ±_opt = 10.0^(c)
    u_guess = copy(u_opt_vec[findmin(abs.(Œ±_vec .- Œ±_opt))[2]])
    u_opt, = my_newton(u -> J(u, Œ±_opt), u -> H(u, Œ±_opt), u_guess)

    #Â§çÂéüËøîÂõûË¶ÅÊ±ÇÁöÑA
    return A_vec(u_opt)
end

function my_chi2kink(
    iwn::Vector{ComplexF64},
    Gvalue::Vector{ComplexF64},
    output_range::Vector{Float64},
)
    output_number = length(output_range)
    N = length(Gvalue)

    # ËÆ°ÁÆóÁßØÂàÜÊó∂ÂÄôÁΩëÊ†ºÁÇπÁöÑÊùÉÈáç
    d = output_range[2] - output_range[1]
    output_weight = fill(d, output_number)

    

    # defualt model
    model = exp.(-output_range .^ 2 / 4)
    # Ë∞ÉÊï¥ÂèÇÊï∞ÔºåÂΩí‰∏ÄÂåñ
    model = model / (model' * output_weight)

    # ÈªòËÆ§ÊµãÈáèGreen function values on image axisÊó∂ÔºåÂêÑ‰∏™ÊµãÈáèÂÄºÁöÑÊ†áÂáÜÂ∑ÆÊòØ1e-4
    œÉ = 1e-4

    # ËÆæÂÆö‰∏ÄÂàó Œ±, ‰ª•ÂèäÂØπÂ∫îÁöÑœá¬≤, ÈïøÂ∫¶ÈªòËÆ§
    L = 16
    Œ±_vec = Vector{Float64}(undef, L)
    Œ±_vec[1] = 1e12
    for i ‚àà 2:L
        Œ±_vec[i] = Œ±_vec[i-1] / 10.0
    end
    œá¬≤_vec = Vector{Float64}(undef, L)

    # ÂêéÈù¢log10(Œ±)Âíålog10(œá¬≤)Ë¶ÅÊãüÂêàÁöÑÊõ≤Á∫ø
    function fitfun(x, p)
        return @. p[1] + p[2] / (1.0 + exp(-p[4] * (x - p[3])))
    end

    # ÊãüÂêàÊõ≤Á∫øÊó∂ÂÄô‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàËÆæÁΩÆÁöÑÂèÇÊï∞
    #adjust = 2.5


    # function Q
    A_vec(u::Vector{Float64}) = model .* exp.(V * u)
    œá¬≤(u::Vector{Float64}) = (G - d * K * A_vec(u))' * (G - d * K * A_vec(u)) / (œÉ^2)
    Q(u::Vector{Float64}, Œ±::Float64) =
        Œ± * (A_vec(u) - model - A_vec(u) .* log.(A_vec(u) ./ model))' * output_weight -
        0.5 * œá¬≤(u)

    # -ùûâQ/‚àÇA
    J(u::Vector{Float64}, Œ±::Float64) =
        Œ± * u + 1 / (œÉ^2) * (-diagm(S) * U' * G + d * diagm(S)^2 * V' * A_vec(u))

    # -‚àÇ¬≤Q/‚àÇA‚àÇu
    H(u::Vector{Float64}, Œ±::Float64) =
        Œ± * Matrix(I(n)) + d / (œÉ^2) * diagm(S)^2 * V' * diagm(A_vec(u)) * V



    # Êé•‰∏ãÊù•Áî®Newton methodÊ±ÇÊúÄÂÄºÁÇπ
    u_guess = zeros(n)
    u_opt_vec = Vector{Vector{Float64}}(undef, L)
    for i = 1:L
        # @show i
        Œ± = Œ±_vec[i]
        u_opt, call, _ = my_newton(u -> J(u, Œ±), u -> H(u, Œ±), u_guess)
        u_guess = copy(u_opt)
        u_opt_vec[i] = copy(u_opt)
        œá¬≤_vec[i] = œá¬≤(u_opt)
        # @show log10(Œ±), log10(œá¬≤_vec[i]), norm(J(u_opt, Œ±)), call
    end
    idx = findall(isfinite, œá¬≤_vec)
    Œ±_vec = Œ±_vec[idx]
    œá¬≤_vec = œá¬≤_vec[idx]
    u_opt_vec = u_opt_vec[idx]

    # Áé∞Âú®ËøõË°åÊõ≤Á∫øÊãüÂêà
    guess_fit = [0.0, 5.0, 2.0, 0.0]
    _, _, c, dd = my_curve_fit(log10.(Œ±_vec), log10.(œá¬≤_vec), guess_fit, Newton())[1]


    # ÈÄâÂèñÊãêÁÇπÔºåÂπ∂‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàÊàñËÄÖÊ¨†ÊãüÂêàÂÅö‰∏ÄÂÆöÂ§ÑÁêÜÔºåÂÜçËÆ°ÁÆóÂØπÂ∫îÁöÑu
    Œ±_opt = 10.0^(c)
    u_guess = copy(u_opt_vec[findmin(abs.(Œ±_vec .- Œ±_opt))[2]])
    u_opt, = my_newton(u -> J(u, Œ±_opt), u -> H(u, Œ±_opt), u_guess)

    #Â§çÂéüËøîÂõûË¶ÅÊ±ÇÁöÑA
    return A_vec(u_opt)
end
#


function my_chi2kink_v2(
    iwn::Vector{ComplexF64},
    Gvalue::Vector{ComplexF64},
    output_range::Vector{Float64};
    model_ite = 0,
)
    output_number = length(output_range)
    N = length(Gvalue)

    # ËÆ°ÁÆóÁßØÂàÜÊó∂ÂÄôÁΩëÊ†ºÁÇπÁöÑÊùÉÈáç
    d = output_range[2] - output_range[1]
    output_weight = fill(d, output_number)

    # set the kernel matrix
    kernel = Matrix{ComplexF64}(undef, N, output_number)
    for i ‚àà 1:N
        for j ‚àà 1:output_number
            kernel[i, j] = 1 / (iwn[i] - output_range[j])
        end
    end

    # real paraliaze Gvalue and kernel
    G = vcat(real(Gvalue), imag(Gvalue))
    K = [real(kernel); imag(kernel)]
    U, S, V = svd(K)
    n = count(x -> (x >= 1e-10), S)
    V = V[:, 1:n]
    U = U[:, 1:n]
    S = S[1:n]

    # ÈªòËÆ§ÊµãÈáèGreen function values on image axisÊó∂ÔºåÂêÑ‰∏™ÊµãÈáèÂÄºÁöÑÊ†áÂáÜÂ∑ÆÊòØ1e-4
    œÉ = 1e-4

    # ËÆæÂÆö‰∏ÄÂàó Œ±, ‰ª•ÂèäÂØπÂ∫îÁöÑœá¬≤, ÈïøÂ∫¶ÈªòËÆ§
    L = 16
    A_res = zeros(N)

    for t ‚àà 0:model_ite
        println("model iter =  $t")
        if t == 0
            model = exp.(-output_range .^ 2 / 4)
            model = model / (model' * output_weight)
        else
            model = copy(A_res)
        end

        Œ±_vec = Vector{Float64}(undef, L)
        Œ±_vec[1] = 1e12
        for i ‚àà 2:L
            Œ±_vec[i] = Œ±_vec[i-1] / 10.0
        end
        œá¬≤_vec = Vector{Float64}(undef, L)

        # ÂêéÈù¢log10(Œ±)Âíålog10(œá¬≤)Ë¶ÅÊãüÂêàÁöÑÊõ≤Á∫ø
        function fitfun(x, p)
            return @. p[1] + p[2] / (1.0 + exp(-p[4] * (x - p[3])))
        end

        # ÊãüÂêàÊõ≤Á∫øÊó∂ÂÄô‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàËÆæÁΩÆÁöÑÂèÇÊï∞
        #adjust = 2.5


        # function Q
        A_vec(u::Vector{Float64}) = model .* exp.(V * u)
        œá¬≤(u::Vector{Float64}) = (G - d * K * A_vec(u))' * (G - d * K * A_vec(u)) / (œÉ^2)
        Q(u::Vector{Float64}, Œ±::Float64) =
            Œ± * (A_vec(u) - model - A_vec(u) .* log.(A_vec(u) ./ model))' * output_weight -
            0.5 * œá¬≤(u)

        # -ùûâQ/‚àÇA
        J(u::Vector{Float64}, Œ±::Float64) =
            Œ± * u + 1 / (œÉ^2) * (-diagm(S) * U' * G + d * diagm(S)^2 * V' * A_vec(u))

        # -‚àÇ¬≤Q/‚àÇA‚àÇu
        H(u::Vector{Float64}, Œ±::Float64) =
            Œ± * Matrix(I(n)) + d / (œÉ^2) * diagm(S)^2 * V' * diagm(A_vec(u)) * V



        # Êé•‰∏ãÊù•Áî®Newton methodÊ±ÇÊúÄÂÄºÁÇπ
        u_guess = zeros(n)
        u_opt_vec = Vector{Vector{Float64}}(undef, L)
        for i = 1:L
            Œ± = Œ±_vec[i]
            u_opt, call, _ = my_newton(u -> J(u, Œ±), u -> H(u, Œ±), u_guess)
            u_guess = copy(u_opt)
            u_opt_vec[i] = copy(u_opt)
            œá¬≤_vec[i] = œá¬≤(u_opt)
        end
        idx = findall(isfinite, œá¬≤_vec)
        Œ±_vec = Œ±_vec[idx]
        œá¬≤_vec = œá¬≤_vec[idx]
        u_opt_vec = u_opt_vec[idx]

        # Áé∞Âú®ËøõË°åÊõ≤Á∫øÊãüÂêà
        guess_fit = [0.0, 5.0, 2.0, 0.0]
        _, _, c, dd = my_curve_fit(log10.(Œ±_vec), log10.(œá¬≤_vec), guess_fit, Newton())[1]


        # ÈÄâÂèñÊãêÁÇπÔºåÂπ∂‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàÊàñËÄÖÊ¨†ÊãüÂêàÂÅö‰∏ÄÂÆöÂ§ÑÁêÜÔºåÂÜçËÆ°ÁÆóÂØπÂ∫îÁöÑu
        Œ±_opt = 10.0^(c)
        u_guess = copy(u_opt_vec[findmin(abs.(Œ±_vec .- Œ±_opt))[2]])
        u_opt, = my_newton(u -> J(u, Œ±_opt), u -> H(u, Œ±_opt), u_guess)

        #Â§çÂéüËøîÂõûË¶ÅÊ±ÇÁöÑA
        A_res = A_vec(u_opt)
    end
    return A_res
end



function ADchi2kink(
    iwn::Vector{ComplexF64},
    Gvalue::Vector{ComplexF64},
    output_range::Vector{Float64},
)
    dAdivdG, dlossdivdG = _ADchi2kink(iwn, Gvalue, output_range)
    @show norm(dAdivdG)
    return dAdivdG, dlossdivdG
end

function _ADchi2kink(
    iwn::Vector{ComplexF64},
    Gvalue::Vector{ComplexF64},
    output_range::Vector{Float64},
)
    output_number = length(output_range)
    N = length(Gvalue)

    # ËÆ°ÁÆóÁßØÂàÜÊó∂ÂÄôÁΩëÊ†ºÁÇπÁöÑÊùÉÈáç
    d = output_range[2] - output_range[1]
    output_weight = fill(d, output_number)

    # set the kernel matrix
    kernel = Matrix{ComplexF64}(undef, N, output_number)
    for i ‚àà 1:N
        for j ‚àà 1:output_number
            kernel[i, j] = 1 / (iwn[i] - output_range[j])
        end
    end

    # real paraliaze Gvalue and kernel
    G = vcat(real(Gvalue), imag(Gvalue))
    K = [real(kernel); imag(kernel)]
    U, S, V = svd(K)
    n = count(x -> (x >= 1e-10), S)
    V = V[:, 1:n]
    U = U[:, 1:n]
    S = S[1:n]

    # defualt model
    model = exp.(-output_range .^ 2 / 4)
    # Ë∞ÉÊï¥ÂèÇÊï∞ÔºåÂΩí‰∏ÄÂåñ
    model = model / (model' * output_weight)

    # ÈªòËÆ§ÊµãÈáèGreen function values on image axisÊó∂ÔºåÂêÑ‰∏™ÊµãÈáèÂÄºÁöÑÊ†áÂáÜÂ∑ÆÊòØ1e-4
    œÉ = 1e-4

    # ËÆæÂÆö‰∏ÄÂàó Œ±, ‰ª•ÂèäÂØπÂ∫îÁöÑœá¬≤, ÈïøÂ∫¶ÈªòËÆ§
    L = 16
    Œ±_vec = Vector{Float64}(undef, L)
    Œ±_vec[1] = 1e12
    for i ‚àà 2:L
        Œ±_vec[i] = Œ±_vec[i-1] / 10.0
    end
    œá¬≤_vec = Vector{Float64}(undef, L)

    # ÂêéÈù¢log10(Œ±)Âíålog10(œá¬≤)Ë¶ÅÊãüÂêàÁöÑÊõ≤Á∫ø
    function fitfun(x, p)
        return @. p[1] + p[2] / (1.0 + exp(-p[4] * (x - p[3])))
    end

    # ÊãüÂêàÊõ≤Á∫øÊó∂ÂÄô‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàËÆæÁΩÆÁöÑÂèÇÊï∞
    #adjust = 2.5


    # function Q
    A_vec(u::Vector{Float64}) = model .* exp.(V * u)
    œá¬≤(u::Vector{Float64}) = (G - d * K * A_vec(u))' * (G - d * K * A_vec(u)) / (œÉ^2)
    Q(u::Vector{Float64}, Œ±::Float64) =
        Œ± * (A_vec(u) - model - A_vec(u) .* log.(A_vec(u) ./ model))' * output_weight -
        0.5 * œá¬≤(u)

    # -ùûâQ/‚àÇA, what we get is a vector, that is to say, column vector
    J(u::Vector{Float64}, Œ±::Float64) =
        Œ± * u + 1 / (œÉ^2) * (-diagm(S) * U' * G + d * diagm(S)^2 * V' * A_vec(u))

    # -‚àÇ¬≤Q/‚àÇA‚àÇu, ‚àÇf/‚àÇu
    H(u::Vector{Float64}, Œ±::Float64) =
        Œ± * Matrix(I(n)) + d / (œÉ^2) * diagm(S)^2 * V' * diagm(A_vec(u)) * V

    # ‚àÇœá¬≤/‚àÇA, get a row vector
    ‚àÇœá¬≤div‚àÇA(u::Vector{Float64}) =
        Matrix(2 / (œÉ^2) * (-d * G' * K + d^2 * A_vec(u)' * V * diagm(S .^ 2) * V'))

    # ‚àÇA/‚àÇu 
    ‚àÇAdiv‚àÇu(u::Vector{Float64}) = diagm(A_vec(u)) * V

    # ‚àÇf/‚àÇG 
    ‚àÇfdiv‚àÇG = -1 / (œÉ^2) * diagm(S) * U'

    # ‚àÇœá¬≤/‚àÇG, get a row vector
    ‚àÇœá¬≤div‚àÇG(u::Vector{Float64}) = Matrix(2 / (œÉ^2) * (G' - d * A_vec(u)' * K'))

    # dœá¬≤/dG 
    dœá¬≤divdG(u::Vector{Float64}, Œ±::Float64) =
        -‚àÇœá¬≤div‚àÇA(u) * ‚àÇAdiv‚àÇu(u) * pinv(H(u, Œ±)) * ‚àÇfdiv‚àÇG + ‚àÇœá¬≤div‚àÇG(u)

    ‚àÇœá¬≤OPTdiv‚àÇG = Matrix{Float64}(undef, L, 2 * N)

    # Êé•‰∏ãÊù•Áî®Newton methodÊ±ÇÊúÄÂÄºÁÇπ
    u_guess = zeros(n)
    u_opt_vec = Vector{Vector{Float64}}(undef, L)
    for i = 1:L
        Œ± = Œ±_vec[i]
        u_opt, = my_newton(u -> J(u, Œ±), u -> H(u, Œ±), u_guess)
        u_guess = copy(u_opt)
        u_opt_vec[i] = copy(u_opt)
        œá¬≤_vec[i] = œá¬≤(u_opt)

        if i == L && !all(isfinite, A_vec(u_opt))
            œá¬≤_vec[i] = NaN
            ‚àÇœá¬≤OPTdiv‚àÇG = ‚àÇœá¬≤OPTdiv‚àÇG[1:(L-1), :]
            break
        end
        ‚àÇœá¬≤OPTdiv‚àÇG[i, :] = dœá¬≤divdG(u_opt, Œ±)
    end
    idx = findall(isfinite, œá¬≤_vec)
    Œ±_vec = Œ±_vec[idx]
    œá¬≤_vec = œá¬≤_vec[idx]
    u_opt_vec = u_opt_vec[idx]


    # Áé∞Âú®ËøõË°åÊõ≤Á∫øÊãüÂêà
    guess_fit = [0.0, 5.0, 2.0, 0.0]
    param, _, reach_tol = my_curve_fit(log10.(Œ±_vec), log10.(œá¬≤_vec), guess_fit, Newton())
    _, _, c, _ = param


    # ÈÄâÂèñÊãêÁÇπÔºåÂπ∂‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàÊàñËÄÖÊ¨†ÊãüÂêàÂÅö‰∏ÄÂÆöÂ§ÑÁêÜÔºåÂÜçËÆ°ÁÆóÂØπÂ∫îÁöÑu
    Œ±_opt = 10.0^(c)
    u_guess = copy(u_opt_vec[findmin(abs.(Œ±_vec .- Œ±_opt))[2]])
    u_opt, = my_newton(u -> J(u, Œ±_opt), u -> H(u, Œ±_opt), u_guess)

    #Â§çÂéüËøîÂõûË¶ÅÊ±ÇÁöÑA
    A_opt = A_vec(u_opt)
    #=
    function _Œ±_opt(œá¬≤_vec1::Vector{Float64})
    	_, _, c, _ = my_curve_fit(log10.(Œ±_vec), log10.(œá¬≤_vec1), guess_fit, Newton())[1]
    	Œ±_opt = 10.0^(c)
    	return Œ±_opt
    end
    dŒ±_optdivdœá¬≤_vec = Zygote.gradient(_Œ±_opt, œá¬≤_vec)[1]
    =#

    #param = param  + [0.0,0.01,0.0,0.1]
    arg = (param, log10.(Œ±_vec), log10.(œá¬≤_vec))
    dpdivdœá¬≤_vec =
        -pinv(‚àÇ¬≤loss_curveDiv‚àÇp¬≤(arg...)) *
        ‚àÇ¬≤loss_‚àÇp‚àÇy(arg...) *
        diagm(1 ./ (œá¬≤_vec * log(10)))
    dcdivdœá¬≤_vec = dpdivdœá¬≤_vec[3, :]'
    dŒ±_optdivdœá¬≤_vec = Œ±_opt * log(10) * dcdivdœá¬≤_vec

    dŒ±_optdivdG = dŒ±_optdivdœá¬≤_vec * ‚àÇœá¬≤OPTdiv‚àÇG
    du_optdivdG = -pinv(H(u_opt, Œ±_opt)) * (‚àÇfdiv‚àÇG + u_opt * dŒ±_optdivdG)
    dA_optdivdG = ‚àÇAdiv‚àÇu(u_opt) * du_optdivdG

    # loss function = ||A1 -A0||_2
    _, S1, V1 = svd(dA_optdivdG)
    dlossdivdG = V1[:, 1] * S1[1] * sqrt(d)

    return dA_optdivdG[:, 1:N] + im * dA_optdivdG[:, (N+1):(2*N)],
    dlossdivdG[1:N] + im * dlossdivdG[(N+1):(2*N)]
end




function ADchi2kink_v2(
    iwn::Vector{ComplexF64},
    Gvalue::Vector{ComplexF64},
    output_range::Vector{Float64},
)
    c_grad, _ = _ADchi2kink_v2(iwn, Gvalue, output_range)
    @show norm(c_grad)
    return c_grad
end

function _ADchi2kink_v2(
    iwn::Vector{ComplexF64},
    Gvalue::Vector{ComplexF64},
    output_range::Vector{Float64},
)
    output_number = length(output_range)
    N = length(Gvalue)

    # ËÆ°ÁÆóÁßØÂàÜÊó∂ÂÄôÁΩëÊ†ºÁÇπÁöÑÊùÉÈáç
    d = output_range[2] - output_range[1]
    output_weight = fill(d, output_number)

    # set the kernel matrix
    kernel = Matrix{ComplexF64}(undef, N, output_number)
    for i ‚àà 1:N
        for j ‚àà 1:output_number
            kernel[i, j] = 1 / (iwn[i] - output_range[j])
        end
    end

    # real paraliaze Gvalue and kernel
    G = vcat(real(Gvalue), imag(Gvalue))
    K = [real(kernel); imag(kernel)]
    U, S, V = svd(K)
    n = count(x -> (x >= 1e-10), S)
    V = V[:, 1:n]
    U = U[:, 1:n]
    S = S[1:n]

    # defualt model
    model = exp.(-output_range .^ 2 / 4)
    # Ë∞ÉÊï¥ÂèÇÊï∞ÔºåÂΩí‰∏ÄÂåñ
    model = model / (model' * output_weight)

    # ÈªòËÆ§ÊµãÈáèGreen function values on image axisÊó∂ÔºåÂêÑ‰∏™ÊµãÈáèÂÄºÁöÑÊ†áÂáÜÂ∑ÆÊòØ1e-4
    œÉ = 1e-4

    # ËÆæÂÆö‰∏ÄÂàó Œ±, ‰ª•ÂèäÂØπÂ∫îÁöÑœá¬≤, ÈïøÂ∫¶ÈªòËÆ§
    L = 16
    Œ±_vec = Vector{Float64}(undef, L)
    Œ±_vec[1] = 1e12
    for i ‚àà 2:L
        Œ±_vec[i] = Œ±_vec[i-1] / 10.0
    end
    œá¬≤_vec = Vector{Float64}(undef, L)

    # ÂêéÈù¢log10(Œ±)Âíålog10(œá¬≤)Ë¶ÅÊãüÂêàÁöÑÊõ≤Á∫ø
    function fitfun(x, p)
        return @. p[1] + p[2] / (1.0 + exp(-p[4] * (x - p[3])))
    end

    # ÊãüÂêàÊõ≤Á∫øÊó∂ÂÄô‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàËÆæÁΩÆÁöÑÂèÇÊï∞
    #adjust = 2.5


    # function Q
    A_vec(u::Vector{Float64}) = model .* exp.(V * u)
    œá¬≤(u::Vector{Float64}) = (G - d * K * A_vec(u))' * (G - d * K * A_vec(u)) / (œÉ^2)
    Q(u::Vector{Float64}, Œ±::Float64) =
        Œ± * (A_vec(u) - model - A_vec(u) .* log.(A_vec(u) ./ model))' * output_weight -
        0.5 * œá¬≤(u)

    # -ùûâQ/‚àÇA, what we get is a vector, that is to say, column vector
    J(u::Vector{Float64}, Œ±::Float64) =
        Œ± * u + 1 / (œÉ^2) * (-diagm(S) * U' * G + d * diagm(S)^2 * V' * A_vec(u))

    # -‚àÇ¬≤Q/‚àÇA‚àÇu, ‚àÇf/‚àÇu
    H(u::Vector{Float64}, Œ±::Float64) =
        Œ± * Matrix(I(n)) + d / (œÉ^2) * diagm(S)^2 * V' * diagm(A_vec(u)) * V

    # ‚àÇœá¬≤/‚àÇA, get a row vector
    ‚àÇœá¬≤div‚àÇA(u::Vector{Float64}) =
        Matrix(2 / (œÉ^2) * (-d * G' * K + d^2 * A_vec(u)' * V * diagm(S .^ 2) * V'))

    # ‚àÇA/‚àÇu 
    ‚àÇAdiv‚àÇu(u::Vector{Float64}) = diagm(A_vec(u)) * V

    # ‚àÇf/‚àÇG 
    ‚àÇfdiv‚àÇG = -1 / (œÉ^2) * diagm(S) * U'

    # ‚àÇœá¬≤/‚àÇG, get a row vector
    ‚àÇœá¬≤div‚àÇG(u::Vector{Float64}) = Matrix(2 / (œÉ^2) * (G' - d * A_vec(u)' * K'))

    # dœá¬≤/dG 
    dœá¬≤divdG(u::Vector{Float64}, Œ±::Float64) =
        -‚àÇœá¬≤div‚àÇA(u) * ‚àÇAdiv‚àÇu(u) * pinv(H(u, Œ±)) * ‚àÇfdiv‚àÇG + ‚àÇœá¬≤div‚àÇG(u)

    ‚àÇœá¬≤OPTdiv‚àÇG = Matrix{Float64}(undef, L, 2 * N)

    # Êé•‰∏ãÊù•Áî®Newton methodÊ±ÇÊúÄÂÄºÁÇπ
    u_guess = zeros(n)
    u_opt_vec = Vector{Vector{Float64}}(undef, L)
    for i = 1:L
        Œ± = Œ±_vec[i]
        u_opt, = my_newton(u -> J(u, Œ±), u -> H(u, Œ±), u_guess)
        u_guess = copy(u_opt)
        u_opt_vec[i] = copy(u_opt)
        œá¬≤_vec[i] = œá¬≤(u_opt)

        if i == L && !all(isfinite, A_vec(u_opt))
            œá¬≤_vec[i] = NaN
            ‚àÇœá¬≤OPTdiv‚àÇG = ‚àÇœá¬≤OPTdiv‚àÇG[1:(L-1), :]
            break
        end
        ‚àÇœá¬≤OPTdiv‚àÇG[i, :] = dœá¬≤divdG(u_opt, Œ±)
    end
    idx = findall(isfinite, œá¬≤_vec)
    Œ±_vec = Œ±_vec[idx]
    œá¬≤_vec = œá¬≤_vec[idx]
    u_opt_vec = u_opt_vec[idx]


    # Áé∞Âú®ËøõË°åÊõ≤Á∫øÊãüÂêà
    guess_fit = [0.0, 5.0, 2.0, 0.0]
    param, _, reach_tol = my_curve_fit(log10.(Œ±_vec), log10.(œá¬≤_vec), guess_fit, Newton())
    _, _, c, _ = param


    # ÈÄâÂèñÊãêÁÇπÔºåÂπ∂‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàÊàñËÄÖÊ¨†ÊãüÂêàÂÅö‰∏ÄÂÆöÂ§ÑÁêÜÔºåÂÜçËÆ°ÁÆóÂØπÂ∫îÁöÑu
    Œ±_opt = 10.0^(c)
    u_guess = copy(u_opt_vec[findmin(abs.(Œ±_vec .- Œ±_opt))[2]])
    u_opt, = my_newton(u -> J(u, Œ±_opt), u -> H(u, Œ±_opt), u_guess)

    #Â§çÂéüËøîÂõûË¶ÅÊ±ÇÁöÑA
    A_opt = A_vec(u_opt)
    #=
    function _Œ±_opt(œá¬≤_vec1::Vector{Float64})
    	_, _, c, _ = my_curve_fit(log10.(Œ±_vec), log10.(œá¬≤_vec1), guess_fit, Newton())[1]
    	Œ±_opt = 10.0^(c)
    	return Œ±_opt
    end
    dŒ±_optdivdœá¬≤_vec = Zygote.gradient(_Œ±_opt, œá¬≤_vec)[1]
    =#

    #param = param  + [0.0,0.01,0.0,0.1]
    arg = (param, log10.(Œ±_vec), log10.(œá¬≤_vec))
    dpdivdœá¬≤_vec =
        -pinv(‚àÇ¬≤loss_curveDiv‚àÇp¬≤(arg...)) *
        ‚àÇ¬≤loss_‚àÇp‚àÇy(arg...) *
        diagm(1 ./ (œá¬≤_vec * log(10)))
    dcdivdœá¬≤_vec = dpdivdœá¬≤_vec[3, :]'
    dŒ±_optdivdœá¬≤_vec = Œ±_opt * log(10) * dcdivdœá¬≤_vec

    dŒ±_optdivdG = dŒ±_optdivdœá¬≤_vec * ‚àÇœá¬≤OPTdiv‚àÇG
    du_optdivdG = -pinv(H(u_opt, Œ±_opt)) * (‚àÇfdiv‚àÇG + u_opt * dŒ±_optdivdG)
    dA_optdivdG = ‚àÇAdiv‚àÇu(u_opt) * du_optdivdG

    function _loss(A_opt1::Vector)
        idx = findall(x -> x > 1e-6, A_opt)
        return sum(exp.(A_opt1[idx] - A_opt[idx]))*d
    end

    # output as a vector
    dlossdivdA_opt = Zygote.gradient(_loss, A_opt)[1]
    res = (dA_optdivdG)' * dlossdivdA_opt
    return res[1:N] + im * res[(N+1):(2*N)], reach_tol
end


function ‚àÇ¬≤loss_curveDiv‚àÇp¬≤(p, x, y)
    a, b, c, d = p
    L = length(x)

    # ËÆ°ÁÆó sigmoid ÂáΩÊï∞ÂèäÂÖ∂Áõ∏ÂÖ≥È°π
    s = 1 ./ (1 .+ exp.(-d * (x .- c)))
    s1 = s .* (1 .- s)  # s1 = s * (1 - s)
    r = a .+ b * s .- y  # ÊÆãÂ∑ÆÈ°π

    # Â°´ÂÖÖÂØπËßíÂÖÉÁ¥†
    Jaa = 2 * L
    Jbb = 2 * sum(s .^ 2)
    Jcc =
        2 * b^2 * d^2 * sum(s .^ 2 .* (1 .- s) .^ 2) +
        2 * b * d^2 * sum(s1 .* (1 .- 2 * s) .* r)
    Jdd =
        2 * sum(
            b^2 * s .^ 2 .* (1 .- s) .^ 2 .* (x .- c) .^ 2 +
            b * (x .- c) .^ 2 .* s1 .* (1 .- 2 * s) .* r,
        )

    # Â°´ÂÖÖÈùûÂØπËßíÂÖÉÁ¥†
    Jab = 2 * sum(s)
    Jac = -2 * b * d * sum(s1)
    Jad = 2 * b * sum(s1 .* (x .- c))
    Jbc = -2 * d * sum(s1 .* (b * s .+ r))
    Jbd = 2 * sum(s1 .* (x .- c) .* (b * s .+ r))
    Jcd =
        -2 *
        b *
        sum(s1 .* (b * d * s1 .* (x .- c) .+ (1 .+ d * (x .- c) .* (1 .- 2 * s)) .* r))

    return [Jaa Jab Jac Jad; Jab Jbb Jbc Jbd; Jac Jbc Jcc Jcd; Jad Jbd Jcd Jdd]
end


function ‚àÇ¬≤loss_‚àÇp‚àÇy(p, x, y)
    a, b, c, d = p
    L = length(x)

    # ËÆ°ÁÆó sigmoid ÂáΩÊï∞ÂèäÂÖ∂Áõ∏ÂÖ≥È°π
    s = 1 ./ (1 .+ exp.(-d * (x .- c)))
    s1 = s .* (1 .- s)  # s1 = s * (1 - s)

    # ÂàùÂßãÂåñÊ∑∑ÂêàÂÅèÂØºÊï∞Áü©Èòµ
    ‚àÇ¬≤loss_‚àÇp‚àÇy_matrix = zeros(4, L)

    # Â°´ÂÖÖÁü©Èòµ
    ‚àÇ¬≤loss_‚àÇp‚àÇy_matrix[1, :] .= -2  # ‚àÇ¬≤loss/‚àÇa‚àÇy_i
    ‚àÇ¬≤loss_‚àÇp‚àÇy_matrix[2, :] = -2 * s  # ‚àÇ¬≤loss/‚àÇb‚àÇy_i
    ‚àÇ¬≤loss_‚àÇp‚àÇy_matrix[3, :] = 2 * b * d * s1  # ‚àÇ¬≤loss/‚àÇc‚àÇy_i
    ‚àÇ¬≤loss_‚àÇp‚àÇy_matrix[4, :] = -2 * b * s1 .* (x .- c)  # ‚àÇ¬≤loss/‚àÇd‚àÇy_i

    return ‚àÇ¬≤loss_‚àÇp‚àÇy_matrix
end


#=
function ADchi2kink(iwn::Vector{ComplexF64}, Gvalue::Vector{ComplexF64}, output_range::Vector{Float64})
	N = length(Gvalue)
	Try_num = 1
	noise = 0.0
	c_grad_opt = zeros(ComplexF64, N)
	min_grad = Inf
	fit_res = false
	for i ‚àà 1:Try_num
		Gvalue += Gvalue .* rand(N) * noise .* exp.(2œÄ * im * rand(N))
		c_grad, reach_tol = _ADchi2kink(iwn, Gvalue, output_range)
		@show norm(c_grad)
		if !reach_tol && norm(c_grad) < min_grad
			fit_res = true
			c_grad_opt = copy(c_grad)
			min_grad = norm(c_grad)
		end
	end
	!fit_res && error("No fit sensitivity analysis found, please try it again!")
	return c_grad_opt
end



function _ADchi2kink(iwn::Vector{ComplexF64}, Gvalue::Vector{ComplexF64}, output_range::Vector{Float64})
	output_number = length(output_range)
	N = length(Gvalue)

	# ËÆ°ÁÆóÁßØÂàÜÊó∂ÂÄôÁΩëÊ†ºÁÇπÁöÑÊùÉÈáç
	d = output_range[2] - output_range[1]
	output_weight = fill(d, output_number)

	# set the kernel matrix
	kernel = Matrix{ComplexF64}(undef, N, output_number)
	for i ‚àà 1:N
		for j ‚àà 1:output_number
			kernel[i, j] = 1 / (iwn[i] - output_range[j])
		end
	end

	# real paraliaze Gvalue and kernel
	G = vcat(real(Gvalue), imag(Gvalue))
	K = [real(kernel); imag(kernel)]
	U, S, V = svd(K)
	n = count(x -> (x >= 1e-10), S)
	V = V[:, 1:n]
	U = U[:, 1:n]
	S = S[1:n]

	# defualt model
	model = exp.(-output_range .^ 2 / 4)
	# Ë∞ÉÊï¥ÂèÇÊï∞ÔºåÂΩí‰∏ÄÂåñ
	model = model / (model' * output_weight)

	# ÈªòËÆ§ÊµãÈáèGreen function values on image axisÊó∂ÔºåÂêÑ‰∏™ÊµãÈáèÂÄºÁöÑÊ†áÂáÜÂ∑ÆÊòØ1e-4
	œÉ = 1e-4

	# ËÆæÂÆö‰∏ÄÂàó Œ±, ‰ª•ÂèäÂØπÂ∫îÁöÑœá¬≤, ÈïøÂ∫¶ÈªòËÆ§
	L = 16
	Œ±_vec = Vector{Float64}(undef, L)
	Œ±_vec[1] = 1e12
	for i ‚àà 2:L
		Œ±_vec[i] = Œ±_vec[i-1] / 10.0
	end
	œá¬≤_vec = Vector{Float64}(undef, L)

	# ÂêéÈù¢log10(Œ±)Âíålog10(œá¬≤)Ë¶ÅÊãüÂêàÁöÑÊõ≤Á∫ø
	function fitfun(x, p)
		return @. p[1] + p[2] / (1.0 + exp(-p[4] * (x - p[3])))
	end

	# ÊãüÂêàÊõ≤Á∫øÊó∂ÂÄô‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàËÆæÁΩÆÁöÑÂèÇÊï∞
	#adjust = 2.5


	# function Q
	A_vec(u::Vector{Float64}) = model .* exp.(V * u)
	œá¬≤(u::Vector{Float64}) = (G - d * K * A_vec(u))' * (G - d * K * A_vec(u)) / (œÉ^2)
	Q(u::Vector{Float64}, Œ±::Float64) = Œ± * (A_vec(u) - model - A_vec(u) .* log.(A_vec(u) ./ model))' * output_weight - 0.5 * œá¬≤(u)

	# -ùûâQ/‚àÇA, what we get is a vector, that is to say, column vector
	J(u::Vector{Float64}, Œ±::Float64) = Œ± * u + 1 / (œÉ^2) * (-diagm(S) * U' * G + d * diagm(S)^2 * V' * A_vec(u))

	# -‚àÇ¬≤Q/‚àÇA‚àÇu, -‚àÇf/‚àÇu
	H(u::Vector{Float64}, Œ±::Float64) = Œ± * Matrix(I(n)) + d / (œÉ^2) * diagm(S)^2 * V' * diagm(A_vec(u)) * V

	# ‚àÇœá¬≤/‚àÇA, get a row vector
	‚àÇœá¬≤div‚àÇA(u::Vector{Float64}) = Matrix(2 / (œÉ^2) * (-d * G' * K + d^2 * A_vec(u)' * V * diagm(S .^ 2) * V'))

	# ‚àÇA/‚àÇu 
	‚àÇAdiv‚àÇu(u::Vector{Float64}) = diagm(A_vec(u)) * V

	# ‚àÇf/‚àÇG 
	‚àÇfdiv‚àÇG = -1 / (œÉ^2) * diagm(S) * U'

	# ‚àÇœá¬≤/‚àÇG, get a row vector
	‚àÇœá¬≤div‚àÇG(u::Vector{Float64}) = Matrix(2 / (œÉ^2) * (G' - d * A_vec(u)' * K'))

	# dœá¬≤/dG 
	dœá¬≤divdG(u::Vector{Float64}, Œ±::Float64) = -‚àÇœá¬≤div‚àÇA(u) * ‚àÇAdiv‚àÇu(u) * pinv(H(u, Œ±)) * ‚àÇfdiv‚àÇG + ‚àÇœá¬≤div‚àÇG(u)

	‚àÇœá¬≤OPTdiv‚àÇG = Matrix{Float64}(undef, L, 2 * N)

	# Êé•‰∏ãÊù•Áî®Newton methodÊ±ÇÊúÄÂÄºÁÇπ
	u_guess = zeros(n)
	u_opt_vec = Vector{Vector{Float64}}(undef, L)
	for i in 1:L
		Œ± = Œ±_vec[i]
		u_opt, = my_newton(u -> J(u, Œ±), u -> H(u, Œ±), u_guess)
		u_guess = copy(u_opt)
		u_opt_vec[i] = copy(u_opt)
		œá¬≤_vec[i] = œá¬≤(u_opt)
		‚àÇœá¬≤OPTdiv‚àÇG[i, :] = dœá¬≤divdG(u_opt, Œ±)
	end
	idx = findall(isfinite, œá¬≤_vec)
	Œ±_vec = Œ±_vec[idx]
	œá¬≤_vec = œá¬≤_vec[idx]
	u_opt_vec = u_opt_vec[idx]


	# Áé∞Âú®ËøõË°åÊõ≤Á∫øÊãüÂêà
	guess_fit = [0.0, 5.0, 2.0, 0.0]
	param, _, reach_tol = my_curve_fit(log10.(Œ±_vec), log10.(œá¬≤_vec), guess_fit, Newton())
	_, _, c, _ = param


	# ÈÄâÂèñÊãêÁÇπÔºåÂπ∂‰∏∫‰∫ÜÈò≤Ê≠¢ËøáÊãüÂêàÊàñËÄÖÊ¨†ÊãüÂêàÂÅö‰∏ÄÂÆöÂ§ÑÁêÜÔºåÂÜçËÆ°ÁÆóÂØπÂ∫îÁöÑu
	Œ±_opt = 10.0^(c)
	u_guess = copy(u_opt_vec[findmin(abs.(Œ±_vec .- Œ±_opt))[2]])
	u_opt, = my_newton(u -> J(u, Œ±_opt), u -> H(u, Œ±_opt), u_guess)

	#Â§çÂéüËøîÂõûË¶ÅÊ±ÇÁöÑA
	A_opt = A_vec(u_opt)


	function _loss(œá¬≤_vec1::Vector{Float64},G::Vector{Float64})
		_, _, c1, _ = my_curve_fit(log10.(Œ±_vec), log10.(œá¬≤_vec1), guess_fit, Newton())[1]
		Œ±_opt1 = 10.0^(c1)
		J1(u::Vector{Float64}, Œ±::Float64) = Œ± * u + 1 / (œÉ^2) * (-diagm(S) * U' * G + d * diagm(S)^2 * V' * A_vec(u))
		u_opt1, = my_newton(u -> J1(u, Œ±_opt1), u -> H(u, Œ±_opt1), u_opt)
		A_opt1 = A_vec(u_opt1)
		idx = findall(x -> x > 1e-3, A_opt)
		return sum(exp.(A_opt1[idx] - A_opt[idx]))*d
	end

	#=
	function _A_opt(œá¬≤_vec1::Vector{Float64},G::Vector{Float64})
		_, _, c, _ = my_curve_fit(log10.(Œ±_vec), log10.(œá¬≤_vec1), guess_fit, Newton())[1]
		Œ±_opt = 10.0^(c)
		J1(u::Vector{Float64}, Œ±::Float64) = Œ± * u + 1 / (œÉ^2) * (-diagm(S) * U' * G + d * diagm(S)^2 * V' * A_vec(u))
		u_opt1, = my_newton(u -> J1(u, Œ±_opt), u -> H(u, Œ±_opt), u_opt)
		A_opt1 = A_vec(u_opt1)
		return A_opt1
	end
	dA_optdivdœá¬≤_vec, ‚àÇA_optdiv‚àÇG = Zygote.jacobian(_A_opt, œá¬≤_vec, G)
	dA_optdivdG = dA_optdivdœá¬≤_vec*‚àÇœá¬≤OPTdiv‚àÇG + ‚àÇA_optdiv‚àÇG
	@show dA_optdivdG[3,:]


	Œ∑ = 1e-5
	œá¬≤_vec1 = œá¬≤_vec + Œ∑ * dŒ±_optdivdœá¬≤_vec
	param1 = my_curve_fit(log10.(Œ±_vec), log10.(œá¬≤_vec1), guess_fit, Newton())[1]
	c1 = param1[3]
	@show c1-c, Œ∑*sum(abs2.(dcdivdœá¬≤_vec))
	=#

	dlossdivdœá¬≤ , ‚àÇlossdiv‚àÇG = Zygote.gradient(_loss, œá¬≤_vec, G)
	res = (‚àÇœá¬≤OPTdiv‚àÇG)' * dlossdivdœá¬≤ + ‚àÇlossdiv‚àÇG
	return res[1:N] + im * res[N+1:2*N], reach_tol
end
=#
